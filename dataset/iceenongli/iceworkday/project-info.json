{"id":99406211,"node_id":"MDEwOlJlcG9zaXRvcnk5OTQwNjIxMQ==","name":"iceworkday","full_name":"iceenongli/iceworkday","private":false,"owner":{"login":"iceenongli","id":27333476,"node_id":"MDQ6VXNlcjI3MzMzNDc2","gravatar_id":"","url":"https://api.github.com/users/iceenongli","type":"User","site_admin":false},"description":"iceworkday工作日算法  工作日算法又称节假日算法。 由于工作日计算涉及农历节气等，而农历算法本身就是非常复杂的，所以工作日算法非常的复杂  。 该算法解决了工作日的计算问题。对以往的数据确保其准确性，对将来的数据提供尽可能准确的  预测。 由于未来的数据是未知的，为了在将来使该算法对已发生的数据具有准确性，该算法提供了配置  文件纠错机制。 该工作日算法的有效计算范围为 2001年--3100年。 对2017年及以前的节假日进行了精确枚举。 WorkUtils.weekendMap(year)方法用于计算节某一年假日map，传入年的字符串。 WorkUtils.isWorkendDay(ymd)方法用于判断某一天是否为节假日，传入年月日字符串。","fork":false,"url":"https://api.github.com/repos/iceenongli/iceworkday","created_at":"2017-08-05T07:14:39Z","updated_at":"2020-06-08T07:04:02Z","pushed_at":"2020-01-29T09:50:48Z","size":49,"stargazers_count":70,"watchers_count":70,"language":"Java","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"forks_count":25,"archived":false,"disabled":false,"open_issues_count":1,"license":{"key":"apache-2.0","name":"Apache License 2.0","spdx_id":"Apache-2.0","url":"https://api.github.com/licenses/apache-2.0","node_id":"MDc6TGljZW5zZTI="},"forks":25,"open_issues":1,"watchers":70,"default_branch":"master","permissions":{"admin":false,"push":false,"pull":true},"temp_clone_token":"","network_count":25,"subscribers_count":5}