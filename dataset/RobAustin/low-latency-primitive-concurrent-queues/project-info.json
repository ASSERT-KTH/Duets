{"id":16251985,"node_id":"MDEwOlJlcG9zaXRvcnkxNjI1MTk4NQ==","name":"low-latency-primitive-concurrent-queues","full_name":"RobAustin/low-latency-primitive-concurrent-queues","private":false,"owner":{"login":"RobAustin","id":6506056,"node_id":"MDQ6VXNlcjY1MDYwNTY=","gravatar_id":"","url":"https://api.github.com/users/RobAustin","type":"User","site_admin":false},"description":"Low latency, lock free, primitive bounded blocking queues backed by an primitive arrays such as an int[]. These classes mimic the interface of BlockingQueue, they work with primitive rather than Objects so are unable to actually implement the BlockingQueue. They take advantage of the Unsafe.putOrdered<X>, which allows the creation of non-blocking code with guaranteed writes. These writes will not be re-orderd by instruction reordering. Under the covers they use a faster store-store barrier, rather than the the slower store-load barrier, which is used when doing a volatile write. One of the trade off with this improved performance is we are limited to a single producer, single consumer. ","fork":false,"url":"https://api.github.com/repos/RobAustin/low-latency-primitive-concurrent-queues","created_at":"2014-01-26T11:31:00Z","updated_at":"2020-01-21T04:42:50Z","pushed_at":"2017-01-27T14:44:12Z","homepage":"www.boundedbuffer.co.uk","size":1523,"stargazers_count":52,"watchers_count":52,"language":"Java","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":true,"forks_count":20,"archived":false,"disabled":false,"open_issues_count":1,"license":{"key":"apache-2.0","name":"Apache License 2.0","spdx_id":"Apache-2.0","url":"https://api.github.com/licenses/apache-2.0","node_id":"MDc6TGljZW5zZTI="},"forks":20,"open_issues":1,"watchers":52,"default_branch":"master","permissions":{"admin":false,"push":false,"pull":true},"temp_clone_token":"","network_count":20,"subscribers_count":10}