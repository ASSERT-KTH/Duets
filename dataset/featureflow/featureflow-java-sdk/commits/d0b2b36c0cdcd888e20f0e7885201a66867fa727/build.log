[INFO] Error stacktraces are turned on.
[INFO] Scanning for projects...
[WARNING] 
[WARNING] Some problems were encountered while building the effective model for io.featureflow:featureflow-java-sdk:jar:1.0.5-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 49, column 15
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-deploy-plugin is missing. @ line 57, column 15
[WARNING] 
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING] 
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING] 
[INFO] Inspecting build with total of 1 modules...
[INFO] Installing Nexus Staging features:
[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin
[INFO] 
[INFO] ----------------< io.featureflow:featureflow-java-sdk >-----------------
[INFO] Building Featureflow Java SDK 1.0.5-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- jacoco-maven-plugin:0.8.5:prepare-agent (default) @ featureflow-java-sdk ---
[INFO] argLine set to -javaagent:/home/jdbl/.m2/repository/org/jacoco/org.jacoco.agent/0.8.5/org.jacoco.agent-0.8.5-runtime.jar=destfile=/tmp/tmpgugubekk/featureflow-java-sdk/target/jacoco.exec
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ featureflow-java-sdk ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ featureflow-java-sdk ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 33 source files to /tmp/tmpgugubekk/featureflow-java-sdk/target/classes
[WARNING] /tmp/tmpgugubekk/featureflow-java-sdk/src/main/java/io/featureflow/client/core/EventsClientImpl.java: /tmp/tmpgugubekk/featureflow-java-sdk/src/main/java/io/featureflow/client/core/EventsClientImpl.java uses unchecked or unsafe operations.
[WARNING] /tmp/tmpgugubekk/featureflow-java-sdk/src/main/java/io/featureflow/client/core/EventsClientImpl.java: Recompile with -Xlint:unchecked for details.
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ featureflow-java-sdk ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ featureflow-java-sdk ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 14 source files to /tmp/tmpgugubekk/featureflow-java-sdk/target/test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:2.19.1:test (default-test) @ featureflow-java-sdk ---
[INFO] Surefire report directory: /tmp/tmpgugubekk/featureflow-java-sdk/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running io.featureflow.client.cucumber.CucumberTest
Feature: Hashing Algorithm

  Scenario Outline: Testing that the key "<key>", salt "<salt>" and feature "<feature>" returns the result "<result>" # hashing.feature:2
    Given the salt is "<salt>", the feature is "<feature>" and the key is "<key>"
    When the variant value is calculated
    Then the hash value calculated should equal "<hash>"
    And the result from the variant calculation should be <result>

    Examples: 

  Scenario Outline: Testing that the key "alice", salt "1" and feature "f1" returns the result "9" # hashing.feature:11
    Given the salt is "1", the feature is "f1" and the key is "alice"                              # HashingAlgorithmStepDefs.the_salt_is_the_feature_is_and_the_key_is(String,String,String)
    When the variant value is calculated                                                           # HashingAlgorithmStepDefs.the_variant_value_is_calculated()
    Then the hash value calculated should equal "de5ce0fbc583fd8"                                  # HashingAlgorithmStepDefs.the_hash_value_calculated_should_equal(String)
    And the result from the variant calculation should be 9                                        # HashingAlgorithmStepDefs.the_result_from_the_variant_calculation_should_be(long)

  Scenario Outline: Testing that the key "bob", salt "1" and feature "f1" returns the result "14" # hashing.feature:12
    Given the salt is "1", the feature is "f1" and the key is "bob"                               # HashingAlgorithmStepDefs.the_salt_is_the_feature_is_and_the_key_is(String,String,String)
    When the variant value is calculated                                                          # HashingAlgorithmStepDefs.the_variant_value_is_calculated()
    Then the hash value calculated should equal "8ecddc9f392dc35"                                 # HashingAlgorithmStepDefs.the_hash_value_calculated_should_equal(String)
    And the result from the variant calculation should be 14                                      # HashingAlgorithmStepDefs.the_result_from_the_variant_calculation_should_be(long)

  Scenario Outline: Testing that the key "alice", salt "2" and feature "f1" returns the result "71" # hashing.feature:13
    Given the salt is "2", the feature is "f1" and the key is "alice"                               # HashingAlgorithmStepDefs.the_salt_is_the_feature_is_and_the_key_is(String,String,String)
    When the variant value is calculated                                                            # HashingAlgorithmStepDefs.the_variant_value_is_calculated()
    Then the hash value calculated should equal "e31eff9e88214f2"                                   # HashingAlgorithmStepDefs.the_hash_value_calculated_should_equal(String)
    And the result from the variant calculation should be 71                                        # HashingAlgorithmStepDefs.the_result_from_the_variant_calculation_should_be(long)

  Scenario Outline: Testing that the key "bob", salt "2" and feature "f1" returns the result "58" # hashing.feature:14
    Given the salt is "2", the feature is "f1" and the key is "bob"                               # HashingAlgorithmStepDefs.the_salt_is_the_feature_is_and_the_key_is(String,String,String)
    When the variant value is calculated                                                          # HashingAlgorithmStepDefs.the_variant_value_is_calculated()
    Then the hash value calculated should equal "591e96e46fc1dad"                                 # HashingAlgorithmStepDefs.the_hash_value_calculated_should_equal(String)
    And the result from the variant calculation should be 58                                      # HashingAlgorithmStepDefs.the_result_from_the_variant_calculation_should_be(long)

  Scenario Outline: Testing that the key "alice", salt "3" and feature "f1" returns the result "36" # hashing.feature:15
    Given the salt is "3", the feature is "f1" and the key is "alice"                               # HashingAlgorithmStepDefs.the_salt_is_the_feature_is_and_the_key_is(String,String,String)
    When the variant value is calculated                                                            # HashingAlgorithmStepDefs.the_variant_value_is_calculated()
    Then the hash value calculated should equal "05ad8a286f0b0bb"                                   # HashingAlgorithmStepDefs.the_hash_value_calculated_should_equal(String)
    And the result from the variant calculation should be 36                                        # HashingAlgorithmStepDefs.the_result_from_the_variant_calculation_should_be(long)

  Scenario Outline: Testing that the key "bob", salt "3" and feature "f1" returns the result "2" # hashing.feature:16
    Given the salt is "3", the feature is "f1" and the key is "bob"                              # HashingAlgorithmStepDefs.the_salt_is_the_feature_is_and_the_key_is(String,String,String)
    When the variant value is calculated                                                         # HashingAlgorithmStepDefs.the_variant_value_is_calculated()
    Then the hash value calculated should equal "9bc2af62801255d"                                # HashingAlgorithmStepDefs.the_hash_value_calculated_should_equal(String)
    And the result from the variant calculation should be 2                                      # HashingAlgorithmStepDefs.the_result_from_the_variant_calculation_should_be(long)
Feature: Rules

  Scenario: Test that the default rule returns a true match # rules.feature:2
    Given the rule is a default rule                        # RulesStepDefs.the_rule_is_a_default_rule()
    When the rule is matched against the user               # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be true           # RulesStepDefs.the_result_from_the_match_should_be_true()

  Scenario Outline: Test that the rule user matching works (User {<attribute>: <attributeValue>} with operator: <operator>, target: <target>, values: <values>, result: <result>) # rules.feature:7
    Given the user attributes are
    And the rule's audience conditions are
    When the rule is matched against the user
    Then the result from the match should be <result>

    Examples: 

  Scenario Outline: Test that the rule user matching works (User {role: "beta"} with operator: equals, target: role, values: ["beta"], result: true) # rules.feature:18
    Given the user attributes are
    And the rule's audience conditions are                                                                                                           # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                                                                                                        # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be true                                                                                                    # RulesStepDefs.the_result_from_the_match_should_be_true()

  Scenario Outline: Test that the rule user matching works (User {role: "alpha"} with operator: equals, target: role, values: ["beta"], result: false) # rules.feature:19
    Given the user attributes are
    And the rule's audience conditions are                                                                                                             # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                                                                                                          # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be false                                                                                                     # RulesStepDefs.the_result_from_the_match_should_be_false()

  Scenario Outline: Test that the rule user matching works (User {role: ["beta", "alpha"]} with operator: equals, target: role, values: ["beta"], result: true) # rules.feature:20
    Given the user attributes are
    And the rule's audience conditions are                                                                                                                      # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                                                                                                                   # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be true                                                                                                               # RulesStepDefs.the_result_from_the_match_should_be_true()

  Scenario Outline: Test that the rule user matching works (User {role: ["beta", "alpha"]} with operator: equals, target: role, values: ["alpha"], result: true) # rules.feature:21
    Given the user attributes are
    And the rule's audience conditions are                                                                                                                       # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                                                                                                                    # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be true                                                                                                                # RulesStepDefs.the_result_from_the_match_should_be_true()

  Scenario Outline: Test that the rule user matching works (User {role: ["beta", "alpha"]} with operator: equals, target: role, values: ["nope"], result: false) # rules.feature:22
    Given the user attributes are
    And the rule's audience conditions are                                                                                                                       # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                                                                                                                    # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be false                                                                                                               # RulesStepDefs.the_result_from_the_match_should_be_false()

  Scenario: Test multiple conditions all passing will return true # rules.feature:24
    Given the user attributes are
    And the rule's audience conditions are                        # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                     # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be true                 # RulesStepDefs.the_result_from_the_match_should_be_true()

  Scenario: Test one conditions, but one failing, will return false # rules.feature:36
    Given the user attributes are
    And the rule's audience conditions are                          # RulesStepDefs.the_rule_s_audience_conditions_are(DataTable)
    When the rule is matched against the user                       # RulesStepDefs.the_rule_is_matched_against_the_user()
    Then the result from the match should be false                  # RulesStepDefs.the_result_from_the_match_should_be_false()

  Scenario Outline: Get the variant split key works for a default case (value: <value>, on: <on>, off: <off>, result: <result>) # rules.feature:49
    Given the variant value of <value>
    And the variant splits are
    When the variant split key is calculated
    Then the resulting variant should be "<result>"

    Examples: 

  Scenario Outline: Get the variant split key works for a default case (value: 50, on: 0, off: 100, result: off) # rules.feature:59
    Given the variant value of 50                                                                                # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                                   # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                                     # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "off"                                                                   # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Get the variant split key works for a default case (value: 50, on: 100, off: 0, result: on) # rules.feature:60
    Given the variant value of 50                                                                               # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                                  # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                                    # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "on"                                                                   # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Get the variant split key works for a default case (value: 11, on: 90, off: 10, result: on) # rules.feature:61
    Given the variant value of 11                                                                               # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                                  # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                                    # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "on"                                                                   # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Get the variant split key works for a default case (value: 9, on: 90, off: 10, result: off) # rules.feature:62
    Given the variant value of 9                                                                                # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                                  # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                                    # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "off"                                                                  # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Testing multiple splits to make sure the right values work (value: <value>, result: <result>) # rules.feature:64
    Given the variant value of <value>
    And the variant splits are
    When the variant split key is calculated
    Then the resulting variant should be "<result>"

    Examples: 

  Scenario Outline: Testing multiple splits to make sure the right values work (value: 1, result: on) # rules.feature:78
    Given the variant value of 1                                                                      # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                        # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                          # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "on"                                                         # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Testing multiple splits to make sure the right values work (value: 30, result: on) # rules.feature:79
    Given the variant value of 30                                                                      # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                         # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                           # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "on"                                                          # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Testing multiple splits to make sure the right values work (value: 50, result: alpha) # rules.feature:80
    Given the variant value of 50                                                                         # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                            # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                              # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "alpha"                                                          # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Testing multiple splits to make sure the right values work (value: 61, result: beta) # rules.feature:81
    Given the variant value of 61                                                                        # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                           # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                             # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "beta"                                                          # RulesStepDefs.the_resulting_variant_should_be(String)

  Scenario Outline: Testing multiple splits to make sure the right values work (value: 100, result: betav2) # rules.feature:82
    Given the variant value of 100                                                                          # RulesStepDefs.the_variant_value_of(int)
    And the variant splits are                                                                              # RulesStepDefs.the_variant_splits_are(DataTable)
    When the variant split key is calculated                                                                # RulesStepDefs.the_variant_split_key_is_calculated()
    Then the resulting variant should be "betav2"                                                           # RulesStepDefs.the_resulting_variant_should_be(String)

23 Scenarios (7 undefined, 16 passed)
91 Steps (21 skipped, 7 undefined, 63 passed)
0m0.357s


You can implement missing steps with the snippets below:

@Given("^the user attributes are$")
public void the_user_attributes_are(DataTable arg1) throws Throwable {
    // Write code here that turns the phrase above into concrete actions
    // For automatic transformation, change DataTable to one of
    // List<YourType>, List<List<E>>, List<Map<K,V>> or Map<K,V>.
    // E,K,V must be a scalar (String, Integer, Date, enum etc)
    throw new PendingException();
}

Tests run: 121, Failures: 0, Errors: 0, Skipped: 35, Time elapsed: 2.45 sec - in io.featureflow.client.cucumber.CucumberTest
Running io.featureflow.client.RuleMatchesTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 sec - in io.featureflow.client.RuleMatchesTest
Running io.featureflow.client.FeatureManagerTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 sec - in io.featureflow.client.FeatureManagerTest
Running io.featureflow.client.OperatorTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.126 sec - in io.featureflow.client.OperatorTest
Running io.featureflow.client.RuleVariantsTest
SEED is 1
alice equals 9
bob equals 14
charlie equals 78
daniel equals 69
emma equals 5
frank equals 54
george equals 45
SEED is 2
alice equals 71
bob equals 58
charlie equals 91
daniel equals 39
emma equals 88
frank equals 8
george equals 61
SEED is 3
alice equals 36
bob equals 2
charlie equals 100
daniel equals 18
emma equals 50
frank equals 2
george equals 16
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 sec - in io.featureflow.client.RuleVariantsTest
Running io.featureflow.client.FeatureControlTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 sec - in io.featureflow.client.FeatureControlTest

Results :

Tests run: 126, Failures: 0, Errors: 0, Skipped: 28

[INFO] 
[INFO] --- jacoco-maven-plugin:0.8.5:report (report) @ featureflow-java-sdk ---
[INFO] Loading execution data file /tmp/tmpgugubekk/featureflow-java-sdk/target/jacoco.exec
[INFO] Analyzed bundle 'Featureflow Java SDK' with 309 classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  23.628 s
[INFO] Finished at: 2020-07-30T22:34:40Z
[INFO] ------------------------------------------------------------------------
